function gencenters(side, λ)
    n = pois_rand(λ * side^3)
    return reduce(hcat, (rand(1:side, 3) for i in 1:n))
end

function genballs(side, R, λ)
    sphere_side = 2R + 1
    padded_side = side + sphere_side
    spheres = zeros(Int8, (padded_side, padded_side, padded_side))
    sphere = zeros(Int8, (sphere_side, sphere_side, sphere_side))
    centers = gencenters(side, λ)
    for i in -R:R
        for j in -R:R
            for k in -R:R
                dist = i^2 + j^2 + k^2
                if dist < R^2
                    sphere[k+R+1, j+R+1, i+R+1] = 1
                end
            end
        end
    end

    for center in (centers[:,i] for i in 1:size(centers,2))
        x = center[1]
        y = center[2]
        z = center[3]
        spheres[x:x + 2R, y:y + 2R, z:z + 2R] .|= sphere
    end
    return spheres[R+1:end-R-1, R+1:end-R-1, R+1:end-R-1]
end

heaviside(x) = max(sign(x), 0)

function s2_theory(r, R, λ)
    tmp = r/R
    tmp2 = (r > 2R) ? 2 : 1 + 3/4*tmp - 1/16*tmp^3
    η = λ * 4/3 * π * R^3
    return exp(-η*tmp2)
end

function ss_theory(r, R, λ)
    η = λ * 4/3 * π * R^3
    tmp = 3η/R
    tmp2 = (tmp * (1 - (0.5 - r/(4R))*heaviside(2R-r)))^2 + tmp/(2r)*heaviside(2R-r)
    return s2_theory(r, R, λ) * tmp2
end

@testset "S2 on random overlapping balls generated by Poisson process" begin
    R = 6; λ = 5e-4
    spheres = genballs(500, R, λ)

    # Calculate in one direction only for speed
    s2_calc = mean(s2(spheres, 200, 0; directions = [:x]))
    ss_calc = mean(surfsurf(spheres, 200, 0; directions = [:x]))

    s2_th = [s2_theory(r, R, λ) for r in 1:200]
    ss_th = [ss_theory(r, R, λ) for r in 1:200]

    err_s2 = relerr.(s2_calc, s2_th)
    err_ss = relerr.(ss_calc, ss_th)

    @test maximum(err_s2) < 0.1
    @test maximum(err_ss[15:end]) < 0.12
    @test_broken maximum(err_ss[1:15]) < 0.12
end
