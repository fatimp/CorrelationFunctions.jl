var documenterSearchIndex = {"docs":
[{"location":"maps.html#Correlation-Maps","page":"Correlation Maps","title":"Correlation Maps","text":"","category":"section"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"The module CorrelationFunctions.Map contains functions which calculate correlation maps, i.e. correlation functions over all possible directions with all possible correlation lengths.","category":"page"},{"location":"maps.html#Functions","page":"Correlation Maps","title":"Functions","text":"","category":"section"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"The following correlation functions are supported:","category":"page"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"Two point S_2 function.\nCluster C_2 function.\nSurface-surface F_ss function.\nSurface-void F_sv function.","category":"page"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"Map.c2\nMap.s2\nMap.cross_correlation\nMap.surf2\nMap.surfvoid\nMap.average_directions","category":"page"},{"location":"maps.html#CorrelationFunctions.Map.c2","page":"Correlation Maps","title":"CorrelationFunctions.Map.c2","text":"c2(image, phase; periodic = false)\n\nCalculate C_2 (cluster) correlation function for the phase phase in an N-dimensional image.\n\nExamples\n\njulia> c2([1 0; 0 1], 1; periodic=true)\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.s2","page":"Correlation Maps","title":"CorrelationFunctions.Map.s2","text":"s2(image; periodic = false)\n\nCalculate S_2 (two point) correlation function for the binary image image.\n\n\n\n\n\ns2(image, phase; periodic = false)\n\nCalculate S_2 (two point) correlation function for the phase phase in an N-dimensional image.\n\nExamples\n\njulia> s2([1 0; 0 1], 1; periodic=true)\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.cross_correlation","page":"Correlation Maps","title":"CorrelationFunctions.Map.cross_correlation","text":"cross_correlation(image1, image2; periodic = false)\n\nCalculate cross-correlation function between binary images image1 and image2.\n\n\n\n\n\ncross_correlation(image, p1, p2; periodic = false)\n\nCalculate cross-correlation function between phases p1 and p2 in an N-dimensional image.\n\nExamples\n\njulia> cross_correlation([1 0; 0 1], 1, 0; periodic=true)\n2×2 Matrix{Float64}:\n 0.0  0.5\n 0.5  0.0\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.surf2","page":"Correlation Maps","title":"CorrelationFunctions.Map.surf2","text":"surf2(image, phase; periodic = false, filter)\n\nCalculate F_ss (surface-surface) correlation function for phase phase on N-dimensional image.\n\nExamples\n\njulia> surf2([1 0; 0 1], 1; periodic=true)\n2×2 Matrix{Float64}:\n 0.125  0.125\n 0.125  0.125\n\nSee also: Utilities.AbstractKernel\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.surfvoid","page":"Correlation Maps","title":"CorrelationFunctions.Map.surfvoid","text":"surfvoid(image, phase; periodic = false, filter)\n\nCalculate F_sv (surface-void) correlation function for phase phase on N-dimensional image. Phase 0 is considered to be void.\n\nExamples\n\njulia> surfvoid([1 0; 0 1], 1; periodic=true)\n2×2 Matrix{Float64}:\n 0.5  0.5\n 0.5  0.5\n\nSee also: Utilities.AbstractKernel\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.average_directions","page":"Correlation Maps","title":"CorrelationFunctions.Map.average_directions","text":"average_directions(cfmap; len = (cfmap |> size |> minimum) ÷ 2)\n\nAverage correlation map cfmap over all directions. The result is a vector of length len with indices being equal to correlation length + 1.\n\n\n\n\n\n","category":"function"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"You can use usual arrays (of type Array) or CUDA arrays for these functions.","category":"page"},{"location":"utilities.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities.html#Edge-detection","page":"Utilities","title":"Edge detection","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"The function extract_edges complements imfilter from Images.jl and can be used to extract edges from an image on CPU and GPU.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.extract_edges\nUtilities.AbstractTopology\nUtilities.Plane\nUtilities.Torus\nUtilities.AbstractKernel\nUtilities.ConvKernel\nUtilities.ErosionKernel","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.extract_edges","page":"Utilities","title":"CorrelationFunctions.Utilities.extract_edges","text":"extract_edges(array, filter, topology)\n\nPerform edge extraction in the same way as in surfsurf and surfvoid functions from Map and Directional modules. array may be a CUDA array or an ordinary array. filter is a value of AbstractKernel type which selects an edge extraction algorithm. Boundary conditions are affected by topology. Periodic boundary conditions are assumed if topology is Torus() and reflection from the boundaries is used if topology is Plane().\n\nSee also: AbstractKernel, AbstractTopology.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.AbstractTopology","page":"Utilities","title":"CorrelationFunctions.Utilities.AbstractTopology","text":"AbstractTopology\n\nAbstract type for describing topology of an input array.\n\nSee also: Plane, Torus.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.Plane","page":"Utilities","title":"CorrelationFunctions.Utilities.Plane","text":"Plane()\n\nTopology for calculation of correlation functions in non-periodic mode. Usually this means zero-padding of an input for out-of-bounds array access.\n\nNB: When extracting edges with Plane topology, reflection from array borders is used for out-of-bounds access. Although, it's natural to assume zero padding must be used, we want an equality F_ss^(false) = F_ss^(true) for two-phase system, hence we cannot pad the input with some constant value.\n\nSee also: AbstractTopology.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.Torus","page":"Utilities","title":"CorrelationFunctions.Utilities.Torus","text":"Torus()\n\nTopology for calculation of correlation functions in periodic mode. An input is extended to the infinity periodically as if it was wrapped around a torus.\n\nSee also: AbstractTopology.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.AbstractKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.AbstractKernel","text":"AbstractKernel\n\nAbstract type for one of edge detecting filters.\n\nSee also: ConvKernel, ErosionKernel.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.ConvKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.ConvKernel","text":"ConvKernel(n)\n\nConvolution kernel of width n used in edge detection. Values 5 and 7 are possible values for n. Using n = 7 works best for the most cases (lowfreq_energy_ratio(array) > 0.97).\n\nSee also: AbstractKernel, extract_edges.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.ErosionKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.ErosionKernel","text":"ErosionKernel(n)\n\nErosion kernel of width n used in edge detection. Used in three-point surface correlation functions.\n\nSee also: AbstractKernel, extract_edges.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#Patterns-for-three-point-functions","page":"Utilities","title":"Patterns for three-point functions","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"These patterns can be used to generate array-like objects which can be used as ps1 and ps2 arguments to the functions based on three-point statistics.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.make_pattern\nUtilities.PlaneXY\nUtilities.PlaneYZ\nUtilities.PlaneXZ\nUtilities.AbstractPlane","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.make_pattern","page":"Utilities","title":"CorrelationFunctions.Utilities.make_pattern","text":"make_pattern(array, plane)\n\nMake a set of points for calculation of correlation functions based on three-point statistics. The created set is based of a right triangle with varying lengths of catheti. The second argument defines alignment of the pattern with one of the planes.\n\nSee also: AbstractPlane, PlaneXY, PlaneXZ, PlaneYZ.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.PlaneXY","page":"Utilities","title":"CorrelationFunctions.Utilities.PlaneXY","text":"PlaneXY()\n\nA designator for a plane defined by vectors [1, 0] and [0, 1] (2D case) or [1, 0, 0] and [0, 1, 0] (3D case).\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.PlaneYZ","page":"Utilities","title":"CorrelationFunctions.Utilities.PlaneYZ","text":"PlaneYZ()\n\nA designator for a plane defined by vectors [0, 1, 0] and [0, 0, 1].\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.PlaneXZ","page":"Utilities","title":"CorrelationFunctions.Utilities.PlaneXZ","text":"PlaneXZ()\n\nA designator for a plane defined by vectors [1, 0, 0] and [0, 0, 1].\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.AbstractPlane","page":"Utilities","title":"CorrelationFunctions.Utilities.AbstractPlane","text":"AbstractPlane\n\nSubtypes of AbstractPlane serve as a plane designators for three-point correlation functions.\n\nSee also: PlaneXY, PlaneXZ, PlaneYZ.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#Misc","page":"Utilities","title":"Misc","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Some miscellaneous functions and helpers.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.read_cuboid\nUtilities.lowfreq_energy_ratio\nUtilities.make_rotation\nUtilities.rotate_array\nUtilities.detect_anisotropy","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.read_cuboid","page":"Utilities","title":"CorrelationFunctions.Utilities.read_cuboid","text":"read_cuboid(datapath :: String, side, dim)\n\nRead 3D array from a disk. The data on the disk must be in binary format, one octet per sample. Totally, there must be side^dim octets which are read into side times side times dots times side array.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.lowfreq_energy_ratio","page":"Utilities","title":"CorrelationFunctions.Utilities.lowfreq_energy_ratio","text":"lowfreq_energy_ratio(array, fraction = 0.5)\n\nCalculate a ratio E_aE where E is a total energy of a signal array and E_a is the energy concentrated in frequencies 0 af2 where f is the sampling rate and a is set via parameter fraction. mean(array) is subtracted from the array before calculations.\n\nThis function can be helpful in estimating if array is suitable for calculating surface-surface or surface-void function. An empirical criterion is that if this function returns a value greater than 0.97, the array is good.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.make_rotation","page":"Utilities","title":"CorrelationFunctions.Utilities.make_rotation","text":"make_rotation(ϕ)\n\nMake a rotation of 2-dimensional data by ϕ radians clockwise.\n\nSee also: rotate_array.\n\n\n\n\n\nmake_rotation(vec :: SVector{3}, ϕ)\n\nMake a rotation of 3-dimensional data by ϕ radians around a vector vec clockwise.\n\nSee also: rotate_array.\n\n\n\n\n\nmake_rotation(m :: SMatrix{D,D})\n\nMake a rotation which transforms unit vectors to columns of m. It is implicitly assumed that any two columns c₁ and c₂ have zero dot product: (c₁, c₂) = 0 and all columns are unit vectors.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.rotate_array","page":"Utilities","title":"CorrelationFunctions.Utilities.rotate_array","text":"rotate_array(array, rot, topology)\n\nRotate an array using rotation defined by rot. The coordinate system's origin is placed into the center of the array. Out-of-bounds array access is specified by topology argument. It is periodic extension of the array if topology is Torus() and zero padding if topology is Plane().\n\nSee also: AbstractTopology, Torus, Plane, make_rotation.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.detect_anisotropy","page":"Utilities","title":"CorrelationFunctions.Utilities.detect_anisotropy","text":"detect_anisotropy(array, phase)\n\nReturn a square matrix which characterizes anisotropy of the specified phase in the input. Each column of the matrix is a unit vector. The first vector points toward anisotropy and the other two vectors are perpendicular to the first vector and to each other. The resulting matrix can be used as an argument to make_rotation.\n\nSee also: rotate_array, make_rotation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#CorrelationFunctions.jl","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"","category":"section"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"This package is a collection of correlation functions described in Salvatore Torquato's book \"Random Heterogeneous Materials\" ISBN 978-1-4757-6357-7. These functions can be calculated for one-, two- or three-dimensional multiphase systems using closed walls (CW) or periodic boundary conditions (PBC) along multiple directions.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"CorrelationFunctions.jl incorporates correlation functions based on two- and three-point statistics. The list of supported functions includes:","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Two point statistics:\nTwo point S_2 function\nCluster C_2 function\nSurface-surface F_ss function\nSurface-void F_sv function\nThree-point statistics:\nThree point S_3 function\nCluster C_3 function\nSurface-surface-surface F_sss function\nSurface-surface-void F_ssv function\nSurface-void-void F_svv function\nOther functions:\nPore size P function\nChord length p function\nLineal-path L_2 function","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Correlation functions based on two-point statistics can be calculated using two slightly different ways. The first way is to calculate them across several predefined directions (e.g. axial directions of an array). Another way is to build a correlation map, in other words to calculate a correlation function in all possible directions in a given array. The first way is implemented in CorrelationFunctions.Directional module and the second is implemented in CorrelationFunctions.Map module. Correlation functions based on three-point statistics are in the first module and are calculated in a selected set of points or using a right triangle pattern.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Here is a documentation for each of those modules and some helper functions.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Directional Functions. Correlation functions across predefined directions and functions based on three-point statistics.\nCorrelation Maps. Correlation maps or correlation functions in all directions.\nUtilities. Utility functions.","category":"page"},{"location":"directional.html#Directional-Functions","page":"Directional Functions","title":"Directional Functions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"This is a documentation for CorrelationFunctions.Directional module. The documentation is divided into the following topics:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Boundary Conditions page describes boundary conditions when calculations cross the boundary of a system.\nDirections page describes directions along which the correlation functions are computed.\nIndicator Functions page describes how to construct customary indicator functions.\nCorrelation Functions page contains the exhaustive list of correlation functions supported by this package.\nResults page contains comparison of correlation functions from this package with some known theoretical results.","category":"page"},{"location":"directional.html#Boundary-Conditions","page":"Directional Functions","title":"Boundary Conditions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"When calculating the value of correlation functions like S_2 or L_2 it may be necessary to cross a boundary of the input array (i.e. access array using an arbitrary index). There two options how CorrelationFunctions.jl handles this situation:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Impose \"closed walls\" (CW) boundary conditions on the input data. This means that the boundary is not crossed and correlation functions gather less statistics for bigger length of test line segments.\nImpose periodic boundary conditions (PBC) on the input data. This means that the input is wrapped around itself (i.e. modular arithmetic is used to access the array).","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"PBC is used when you specify periodic = true when call a correlation function, otherwise CW is used.","category":"page"},{"location":"directional.html#Directions","page":"Directional Functions","title":"Directions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Functions based on two-point statistics from Directional module will require a direction along which the function is calculated (usually as their third argument). You can specify these directions:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Utilities.DirX\nUtilities.DirY\nUtilities.DirZ\nUtilities.DirXY\nUtilities.DirYX\nUtilities.DirXZ\nUtilities.DirZX\nUtilities.DirYZ\nUtilities.DirZY\nUtilities.DirXYZ\nUtilities.DirXZY\nUtilities.DirYXZ\nUtilities.DirZYX\nUtilities.AbstractDirection","category":"page"},{"location":"directional.html#CorrelationFunctions.Utilities.DirX","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirX","text":"DirX()\n\nA subtype of AbstractDirection Corresponds to vectors [1], [1, 0] or [1, 0, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirY","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirY","text":"DirY()\n\nA subtype of AbstractDirection Corresponds to vectors [0, 1] or [0, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirZ","text":"DirZ()\n\nA subtype of AbstractDirection Corresponds to a vector [0, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirXY","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirXY","text":"DirXY()\n\nA subtype of AbstractDirection Corresponds to vectors [1, 1] or [1, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirYX","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirYX","text":"DirYX()\n\nA subtype of AbstractDirection Corresponds to vectors [-1, 1] or [-1, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirXZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirXZ","text":"DirXZ()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirZX","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirZX","text":"DirZX()\n\nA subtype of AbstractDirection Corresponds to a vector [-1, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirYZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirYZ","text":"DirYZ()\n\nA subtype of AbstractDirection Corresponds to a vector [0, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirZY","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirZY","text":"DirZY()\n\nA subtype of AbstractDirection Corresponds to a vector [0, -1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirXYZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirXYZ","text":"DirXYZ()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirXZY","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirXZY","text":"DirXZY()\n\nA subtype of AbstractDirection Corresponds to a vector [1, -1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirYXZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirYXZ","text":"DirYXZ()\n\nA subtype of AbstractDirection Corresponds to a vector [-1, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirZYX","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirZYX","text":"DirZYX()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 1, -1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.AbstractDirection","page":"Directional Functions","title":"CorrelationFunctions.Utilities.AbstractDirection","text":"AbstractDirection\n\nAbstract type for direction vectors used in calculation of directional correlation functions. Each subtype of AbstractDirection corresponds with one 2D and/or one 3D vector along which slices are taken for calculation.\n\nSee also: DirX, DirY, DirZ, DirXY, DirYX, DirXZ, DirZX, DirYZ, DirZY, DirXYZ, DirXZY, DirYXZ, DirZYX.\n\n\n\n\n\n","category":"type"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The module Map can use these directions to extract directional information from correlation maps.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"These rules can help you to memoize the correspondence between symbolic designations and vectors:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"DirFoo types can contain from one to three characters X, Y and Z. Each character can occur only once (there is a type DirXYZ, but no type DirXXY).\nWhen a character does not occur is a designation (e.g, there is no Z in DirXY) that coordinate remains constant in a slice (in the example above z = textconst).\nThe names of the axes have a \"natural order\" which is X, Y, Z. In a designation, the first axis which breaks that order get the minus sign in the direction vector (e.g. DirXZY equals to (1, -1, 1) because Y is in the third position, not in the second, DirZX equals to (-1, 0, 1) because X is in the second position, not in the first, etc.)","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Functions based on three-point statistics require a set of points in which they are calculated (usually as the third and the fourth arguments). This set can be generated by Utilities.make_pattern function.","category":"page"},{"location":"directional.html#Indicator-Functions","page":"Directional Functions","title":"Indicator Functions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Internally, the functions c2, surf2 and surfvoid (see Correlation Functions) are reduced to s2 passing more generic indicator functions rather than simply a phase. This feature is also exposed to users. If you want to use a custom indicator function, you need to wrap it to either SeparableIndicator or InseparableIndicator structure, calling the corresponding constructor. Note that s2 performs much better on big arrays when using SeparableIndicator.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.AbstractIndicator\nDirectional.SeparableIndicator\nDirectional.InseparableIndicator","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.AbstractIndicator","page":"Directional Functions","title":"CorrelationFunctions.Directional.AbstractIndicator","text":"Abstract type for indicator functions mathbbR^2n rightarrow left0 1right where n = 1 2 text or  3.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Directional.SeparableIndicator","page":"Directional Functions","title":"CorrelationFunctions.Directional.SeparableIndicator","text":"SeparableIndicator(χ₁, χ₂)\n\nType for separable indicator function, that is for such an indicator function which can be written as chi(xy) = chi_1(x)chi_2(y).\n\nχ1 and χ2 must be functions of one argument which return a value of Bool type.\n\nNB: This indicator function is not symmetric (i.e. chi(xy) ne chi(yx)). This behaviour is intentional. For example you can write such an indicator, so the corresponding correlation function is sensitive to the spatial orientation of a system.\n\n\"That one, too fat! This one, too tall! This one… too symmetrical!\"\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Directional.InseparableIndicator","page":"Directional Functions","title":"CorrelationFunctions.Directional.InseparableIndicator","text":"InseparableIndicator(χ)\n\nType for inseparable indicator function, that is for such an indicator function which cannot be written as chi(xy) = chi_1(x)chi_2(y).\n\nχ must be a function of two arguments which returns a value of Bool type.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#Correlation-Functions","page":"Directional Functions","title":"Correlation Functions","text":"","category":"section"},{"location":"directional.html#Two-point-statistics","page":"Directional Functions","title":"Two-point statistics","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.s2\nDirectional.c2\nDirectional.cross_correlation\nDirectional.surf2\nDirectional.surfvoid","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.s2","page":"Directional Functions","title":"CorrelationFunctions.Directional.s2","text":"s2(array, phase, direction[; len] [,periodic = false])\ns2(array, SeparableIndicator(χ₁, χ₂), direction[; len] [,periodic = false])\ns2(array, InseparableIndicator(χ), direction[; len] [,periodic = false])\n\nCalculate S₂ (two point) correlation function for one-, two- or three-dimensional multiphase system.\n\nS₂(x) equals to probability that corner elements of a line segment with the length x cut from the array belong to the same phase. This implementation calculates S₂(x) for all xes in the range from 1 to len which defaults to half of the minimal dimenstion of the array.\n\nMore generally, you can provide indicator function χ instead of phase. In this case S₂ function calculates probability of χ(x, y) returing true where x and y are two corners of a line segment. Indicator functions must be wrapped in either SeparableIndicator or InseparableIndicator. Some computations for separable indicator functions are optimized.\n\nExamples\n\njulia> s2([1,1,1,0,1,1], 1, DirX(); len = 6)\n6-element Vector{Float64}:\n 0.8333333333333334\n 0.6\n 0.5\n 0.6666666666666666\n 1.0\n 1.0\n\nSee also: Utilities.AbstractDirection, SeparableIndicator, InseparableIndicator.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.c2","page":"Directional Functions","title":"CorrelationFunctions.Directional.c2","text":"c2(array, phase, direction[; len,] [periodic = false])\n\nCalculate C₂ (cluster) correlation function for one-, two- or three-dimensional multiphase system.\n\nC₂(x) equals to probability that corner elements of a line segment with the length x cut from the array belong to the same cluster of the specific phase. This implementation calculates C2 for all xes in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nExamples\n\njulia> c2([1,1,1,0,1,1], 1, DirX(); len = 6)\n6-element Array{Float64,1}:\n 0.8333333333333333\n 0.5999999999999999\n 0.24999999999999994\n 2.4671622769447922e-17\n 9.25185853854297e-17\n 5.181040781584064e-16\n\nFor a list of possible directions, see also: Utilities.AbstractDirection.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.cross_correlation","page":"Directional Functions","title":"CorrelationFunctions.Directional.cross_correlation","text":"cross_correlation(array, phase1, phase2, direction[; len] [,periodic = false])\n\nCalculate cross-correlation between phase1 and phase2 in array. The meaning of optional arguments is the same as for s2 function.\n\nSee also: s2.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surf2","page":"Directional Functions","title":"CorrelationFunctions.Directional.surf2","text":"surf2(array, phase, direction[; len] [,periodic = false][, filter])\n\nCalculate surface-surface correlation function for one-, two- or three-dimensional multiphase system. This implementation calculates surface-surface function for all xs in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nIf phase is a function it is applied to array to select the phase of interest, otherwise the phase of interest is selected by testing elements of array for equality with phase.\n\nSee also: Utilities.AbstractDirection, Utilities.AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surfvoid","page":"Directional Functions","title":"CorrelationFunctions.Directional.surfvoid","text":"surfvoid(array, phase, direction[; len] [,void_phase = 0][, periodic = false][, filter])\n\nCalculate surface-void correlation function for one-, two- or three-dimensional multiphase system. This implementation calculates surface-void function for all xs in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nIf phase is a function it is applied to array to select the phase of interest, otherwise the phase of interest is selected by testing elements of array for equality with phase. void_phase can also be either a function or some other object and is used as an indicator for the void phase.\n\nSee also: Utilities.AbstractDirection, Utilities.AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#Three-point-statistics","page":"Directional Functions","title":"Three-point statistics","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.s3\nDirectional.c3\nDirectional.surf3\nDirectional.surf2void\nDirectional.surfvoid2","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.s3","page":"Directional Functions","title":"CorrelationFunctions.Directional.s3","text":"s3(array, ps1, ps2[, periodic = false])\n\nCalculate the three-point correlation function in an array of points.\n\nTwo arguments ps1 and ps2 must be arrays of N-tuples of integers (where N is a dimensionality of the input array) broadcastable to the same size. Periodic or zero-padding boundary conditions are selected with the choose of periodic argument.\n\nThe following invariants hold:\n\njulia> data = rand(Bool, (100, 100, 100));\njulia> shiftsx = [(i, 0, 0) for i in 0:49];\njulia> shiftsy = [(0, i, 0) for i in 0:49];\njulia> shiftsz = [(0, 0, i) for i in 0:49];\njulia> s2x = D.s2(data, 1, U.DirX());\njulia> s2y = D.s2(data, 1, U.DirY());\njulia> s2z = D.s2(data, 1, U.DirZ());\njulia> s2x_ = D.s3(data, [(0,0,0)], shiftsx);\njulia> s2y_ = D.s3(data, [(0,0,0)], shiftsy);\njulia> s2z_ = D.s3(data, [(0,0,0)], shiftsz);\n\njulia> s2x == s2x_\ntrue\n\njulia> s2y == s2y_\ntrue\n\njulia> s2z == s2z_\ntrue\n\nSee also: make_pattern, s2.\n\n\n\n\n\ns3(array, phase, ps1, ps2[; periodic = false])\n\nThe same as s3(array .== phase; ...). Kept for consistency with other parts of the API.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.c3","page":"Directional Functions","title":"CorrelationFunctions.Directional.c3","text":"c3(array, phase[; planes :: Vector{AbstractPlane}, len, periodic = false])\n\nCalculate three-point cluster correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nSee also: s3, AbstractPlane.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surf3","page":"Directional Functions","title":"CorrelationFunctions.Directional.surf3","text":"surf3(array, ps1, ps2[; periodic = false][, filter :: AbstractKernel])\n\nCalculate surface-surface-surface (F_sss) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nSee also: s3, make_pattern, AbstractKernel.\n\n\n\n\n\nsurf3(array, phase[; periodic = false][, filter = ConvKernel(7)])\n\nThe same as surf3(array .== phase; ...). Kept for consistency with other parts of the API.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surf2void","page":"Directional Functions","title":"CorrelationFunctions.Directional.surf2void","text":"surf2void(array, phase, ps1, ps2[, void_phase = 0][; periodic = false][, filter :: AbstractKernel])\n\nCalculate surface-surface-void (F_ssv) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nSee also: s3, make_pattern, AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surfvoid2","page":"Directional Functions","title":"CorrelationFunctions.Directional.surfvoid2","text":"surfvoid2(array, phase, ps1, ps2[, void_phase = 0][; periodic = false][, filter :: AbstractKernel])\n\nCalculate surface-void-void (F_svv) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nSee also: s3, AbstractPlane, AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#Other-correlation-functions","page":"Directional Functions","title":"Other correlation functions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.pore_size\nDirectional.chord_length\nDirectional.l2","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.pore_size","page":"Directional Functions","title":"CorrelationFunctions.Directional.pore_size","text":"pore_size(array, phase = 0; periodic = false)\n\nCalculate pore size correlation function for one-, two- or three-dimensional multiphase systems.\n\nThis implementation returns an array of pore sizes where each size is equal to the distance from a particular point in the pore to the closest point not belonging to the phase phase.\n\nExample\n\njulia> data = [1 1 1 1 1; 1 1 0 1 1; 1 0 0 0 1; 1 1 0 1 1; 1 1 1 1 1]\n5×5 Matrix{Int64}:\n 1  1  1  1  1\n 1  1  0  1  1\n 1  0  0  0  1\n 1  1  0  1  1\n 1  1  1  1  1\n\njulia> D.pore_size(data, 0)\n5-element Vector{Float64}:\n 1.0\n 1.0\n 1.4142135623730951\n 1.0\n 1.0\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.chord_length","page":"Directional Functions","title":"CorrelationFunctions.Directional.chord_length","text":"chord_length(array, phase, direction)\n\nCalculate the chord length correlation function for one-, two- or three-dimensional multiphase systems.\n\nA chord is a line segment which touches the boundary of a same-phase cluster with its ends.\n\nThis implementation returns an array of chord lengths where each length is equal to a number of voxels in the phase phase belonging to a chord.\n\nExamples\n\njulia> chord_length([1, 0, 0, 0, 0, 1, 0, 1], 0, DirX())\n2-element Vector{Int64}:\n 4\n 1\n\nFor a list of possible dimensions, see also: Utilities.AbstractDirection.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.l2","page":"Directional Functions","title":"CorrelationFunctions.Directional.l2","text":"l2(array, phase, direction[; len][, periodic = false])\n\nCalculate L₂ (lineal path) correlation function for one-, two- or three-dimensional multiphase system.\n\nL₂(x) equals to probability that all elements of a line segment with length x cut from the array belong to the same phase. This implementation calculates L₂(x) for all xes in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nExamples\n\njulia> l2([1,1,1,0,1,1], 1, DirX(); len = 6)\n6-element Array{Float64,1}:\n 0.8333333333333334\n 0.6\n 0.25\n 0.0\n 0.0\n 0.0\n\nFor a list of possible dimensions, see also: Utilities.AbstractDirection.\n\n\n\n\n\n","category":"function"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The pore_size function is also reexported from CorrelationFunctions directly, not being actually a \"directional\" function.","category":"page"},{"location":"directional.html#Results","page":"Directional Functions","title":"Results","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"CorrelationFunctions.jl is tested on overlapping disks and balls of constant radius R with centers generated by Poisson process with parameter lambda (see section 5.1 of Random Heterogeneous Materials). An example of a two-dimensional two-phase system generated in this way is on the picture (R = 25 and lambda = 5 cdot 10^-4):","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"(Image: disks)","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Plots of all correlation functions calculated by CorrelationFunctions.jl for overlapping disks along with their theoretical values are given below. There are also plots of relative errors calculated as","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"texterr(x) = mid fractextcalculation(x) -\ntexttheory(x)texttheory(x) mid","category":"page"},{"location":"directional.html#Two-dimensional-systems","page":"Directional Functions","title":"Two-dimensional systems","text":"","category":"section"},{"location":"directional.html#Methodology","page":"Directional Functions","title":"Methodology","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"All functions in this section with exception of pore size and chord length functions are calculated on 15 random datasets generated with parameters R = 25 and lambda = 5 cdot 10^-4. Each dataset is an image with dimensions 4000x4000 pixels. The final result is an average of results on those 15 datasets. When function fastly decreases to zero a plot of a natural logarithm of that function is provided.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size and chord length functions are calculated on one 4000x4000 dataset with the same parameters as above. A theoretical value is computed by averaging a theoretical function across each bin of a histogram returned by pore_size or chord_length function. Because both pore size and cord length functions decrease to zero with increase of their arguments, the relative errors are calculated for the corresponding cummulative distribution functions.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"All functions are called with default optional arguments unless explicitly stated otherwise.","category":"page"},{"location":"directional.html#Two-point-S_2(x)-function","page":"Directional Functions","title":"Two point S_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"S2 Error\n(Image: s2) (Image: s2 error)","category":"page"},{"location":"directional.html#Lineal-path-L_2(x)-function","page":"Directional Functions","title":"Lineal path L_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"L2 Error\n(Image: l2) (Image: l2 error)","category":"page"},{"location":"directional.html#Surface-surface-F_{ss}(x)-function","page":"Directional Functions","title":"Surface-surface F_ss(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-surface Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Surface-void-F_{sv}(x)-function","page":"Directional Functions","title":"Surface-void F_sv(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-void Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Pore-size-P(x)-function","page":"Directional Functions","title":"Pore size P(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Chord-length-p(x)-function","page":"Directional Functions","title":"Chord length p(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length function chord_length was called with parameter nbins = 30.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Three-dimensional-systems","page":"Directional Functions","title":"Three-dimensional systems","text":"","category":"section"},{"location":"directional.html#Methodology-2","page":"Directional Functions","title":"Methodology","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The idea is the same as in two-dimensional case, but chosen parameters are slightly different. The functions are averaged over 5 500x500x500 datasets with ball radius R = 20 and Poisson process parameter lambda = 3 cdot 10^-5.","category":"page"},{"location":"directional.html#Two-point-S_2(x)-function-2","page":"Directional Functions","title":"Two point S_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"S2 Error\n(Image: s2) (Image: s2 error)","category":"page"},{"location":"directional.html#Lineal-path-L_2(x)-function-2","page":"Directional Functions","title":"Lineal path L_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"L2 Error\n(Image: l2) (Image: l2 error)","category":"page"},{"location":"directional.html#Surface-surface-F_{ss}(x)-function-2","page":"Directional Functions","title":"Surface-surface F_ss(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-surface Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Surface-void-F_{sv}(x)-function-2","page":"Directional Functions","title":"Surface-void F_sv(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-void Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Pore-size-P(x)-function-2","page":"Directional Functions","title":"Pore size P(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Chord-length-p(x)-function-2","page":"Directional Functions","title":"Chord length p(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length function chord_length was called with parameter nbins = 30.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length Error\n(Image: ss) (Image: ss error)","category":"page"}]
}
