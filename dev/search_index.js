var documenterSearchIndex = {"docs":
[{"location":"maps.html#Correlation-Maps","page":"Correlation Maps","title":"Correlation Maps","text":"","category":"section"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"The module CorrelationFunctions.Map contains functions which calculate correlation maps, i.e. correlation functions over all possible directions with all possible correlation lengths.","category":"page"},{"location":"maps.html#Functions","page":"Correlation Maps","title":"Functions","text":"","category":"section"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"The following correlation functions are supported:","category":"page"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"Two point S_2 function.\nCluster C_2 function.\nSurface-surface F_ss function.\nSurface-void F_sv function.","category":"page"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"Map.c2\nMap.s2\nMap.cross_correlation\nMap.surf2\nMap.surfvoid\nMap.average_directions","category":"page"},{"location":"maps.html#CorrelationFunctions.Map.c2","page":"Correlation Maps","title":"CorrelationFunctions.Map.c2","text":"c2(image, phase; mode = NonPeriodic())\n\nCalculate C_2 (cluster) correlation function for the phase phase in an N-dimensional image.\n\nExamples\n\njulia> c2([1 0; 0 1], 1; mode = Periodic())\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.s2","page":"Correlation Maps","title":"CorrelationFunctions.Map.s2","text":"s2(image; mode = NonPeriodic())\n\nCalculate S_2 (two point) correlation function for the binary image image.\n\n\n\n\n\ns2(image, phase; mode = NonPeriodic())\n\nCalculate S_2 (two point) correlation function for the phase phase in an N-dimensional image.\n\nExamples\n\njulia> s2([1 0; 0 1], 1; mode = Periodic())\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.cross_correlation","page":"Correlation Maps","title":"CorrelationFunctions.Map.cross_correlation","text":"cross_correlation(image1, image2; mode = NonPeriodic())\n\nCalculate cross-correlation function between binary images image1 and image2.\n\n\n\n\n\ncross_correlation(image, p1, p2; mode = NonPeriodic)\n\nCalculate cross-correlation function between phases p1 and p2 in an N-dimensional image.\n\nExamples\n\njulia> cross_correlation([1 0; 0 1], 1, 0; mode = Periodic())\n2×2 Matrix{Float64}:\n 0.0  0.5\n 0.5  0.0\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.surf2","page":"Correlation Maps","title":"CorrelationFunctions.Map.surf2","text":"surf2(image, phase; mode = NonPeriodic(), filter)\n\nCalculate F_ss (surface-surface) correlation function for phase phase on N-dimensional image.\n\nExamples\n\njulia> surf2([1 0; 0 1], 1; mode = Periodic())\n2×2 Matrix{Float64}:\n 0.125  0.125\n 0.125  0.125\n\nSee also: Utilities.AbstractKernel\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.surfvoid","page":"Correlation Maps","title":"CorrelationFunctions.Map.surfvoid","text":"surfvoid(image, phase; mode = NonPeriodic(), filter)\n\nCalculate F_sv (surface-void) correlation function for phase phase on N-dimensional image. Phase 0 is considered to be void.\n\nExamples\n\njulia> surfvoid([1 0; 0 1], 1; mode = Periodic())\n2×2 Matrix{Float64}:\n 0.5  0.5\n 0.5  0.5\n\nSee also: Utilities.AbstractKernel\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.average_directions","page":"Correlation Maps","title":"CorrelationFunctions.Map.average_directions","text":"average_directions(cfmap; len = (cfmap |> size |> minimum) ÷ 2)\n\nAverage correlation map cfmap over all directions. The result is a vector of length len with indices being equal to correlation length + 1.\n\n\n\n\n\n","category":"function"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"You can use usual arrays (of type Array) or CUDA arrays for these functions.","category":"page"},{"location":"utilities.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities.html#Edge-detection","page":"Utilities","title":"Edge detection","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"The function extract_edges complements imfilter from Images.jl and can be used to extract edges from an image on CPU and GPU.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.extract_edges\nUtilities.AbstractKernel\nUtilities.ConvKernel\nUtilities.ErosionKernel","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.extract_edges","page":"Utilities","title":"CorrelationFunctions.Utilities.extract_edges","text":"extract_edges(array, filter, mode)\n\nPerform edge extraction in the same way as in surfsurf and surfvoid functions from Map and Directional modules. array may be a CUDA array or an ordinary array. filter is a value of AbstractKernel type which selects an edge extraction algorithm. Boundary conditions are affected by mode. Periodic boundary conditions are assumed if mode is Periodic() and reflection from the boundaries is used if mode is NonPeriodic().\n\nNB: We use reflection instead of zero-padding with NonPeriodic() to ensure that F_ss^(0) == F_ss^(1) for two-phase media.\n\nSee also: AbstractKernel, AbstractMode.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.AbstractKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.AbstractKernel","text":"AbstractKernel\n\nAbstract type for one of edge detecting filters.\n\nSee also: ConvKernel, ErosionKernel.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.ConvKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.ConvKernel","text":"ConvKernel(n)\n\nConvolution kernel of width n used in edge detection. Values 5 and 7 are possible values for n. Using n = 7 works best for the most cases (lowfreq_energy_ratio(array) > 0.97).\n\nSee also: AbstractKernel, extract_edges.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.ErosionKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.ErosionKernel","text":"ErosionKernel(n)\n\nErosion kernel of width n used in edge detection. Used in three-point surface correlation functions.\n\nSee also: AbstractKernel, extract_edges.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#Patterns-for-three-point-functions","page":"Utilities","title":"Patterns for three-point functions","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"These patterns can be used to generate array-like objects which can be used as ps1 and ps2 arguments to the functions based on three-point statistics.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.right_triangles\nUtilities.PlaneXY\nUtilities.PlaneYZ\nUtilities.PlaneXZ\nUtilities.AbstractPlane","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.right_triangles","page":"Utilities","title":"CorrelationFunctions.Utilities.right_triangles","text":"right_triangles(array, plane)\n\nMake a set of points for calculation of correlation functions based on three-point statistics. The created set is based of a right triangle with varying lengths of catheti. The second argument defines alignment of the pattern with one of the planes.\n\nSee also: AbstractPlane, PlaneXY, PlaneXZ, PlaneYZ.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.PlaneXY","page":"Utilities","title":"CorrelationFunctions.Utilities.PlaneXY","text":"PlaneXY()\n\nA designator for a plane defined by vectors [1, 0] and [0, 1] (2D case) or [1, 0, 0] and [0, 1, 0] (3D case).\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.PlaneYZ","page":"Utilities","title":"CorrelationFunctions.Utilities.PlaneYZ","text":"PlaneYZ()\n\nA designator for a plane defined by vectors [0, 1, 0] and [0, 0, 1].\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.PlaneXZ","page":"Utilities","title":"CorrelationFunctions.Utilities.PlaneXZ","text":"PlaneXZ()\n\nA designator for a plane defined by vectors [1, 0, 0] and [0, 0, 1].\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.AbstractPlane","page":"Utilities","title":"CorrelationFunctions.Utilities.AbstractPlane","text":"AbstractPlane\n\nSubtypes of AbstractPlane serve as a plane designators for three-point correlation functions.\n\nSee also: PlaneXY, PlaneXZ, PlaneYZ.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#Misc","page":"Utilities","title":"Misc","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Some miscellaneous functions and helpers.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.read_cuboid\nUtilities.lowfreq_energy_ratio","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.read_cuboid","page":"Utilities","title":"CorrelationFunctions.Utilities.read_cuboid","text":"read_cuboid(datapath :: String, side, dim)\n\nRead 3D array from a disk. The data on the disk must be in binary format, one octet per sample. Totally, there must be side^dim octets which are read into side times side times dots times side array.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.lowfreq_energy_ratio","page":"Utilities","title":"CorrelationFunctions.Utilities.lowfreq_energy_ratio","text":"lowfreq_energy_ratio(array, fraction = 0.5)\n\nCalculate a ratio E_aE where E is a total energy of a signal array and E_a is the energy concentrated in frequencies 0 af2 where f is the sampling rate and a is set via parameter fraction. mean(array) is subtracted from the array before calculations.\n\nThis function can be helpful in estimating if array is suitable for calculating surface-surface or surface-void function. An empirical criterion is that if this function returns a value greater than 0.97, the array is good.\n\n\n\n\n\n","category":"function"},{"location":"index.html#CorrelationFunctions.jl","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"","category":"section"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"This package is a collection of correlation functions described in Salvatore Torquato's book \"Random Heterogeneous Materials\" ISBN 978-1-4757-6357-7. These functions can be calculated for one-, two- or three-dimensional multiphase systems using closed walls (CW) or periodic boundary conditions (PBC) along multiple directions.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"CorrelationFunctions.jl incorporates correlation functions based on two- and three-point statistics. The list of supported functions includes:","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Two point statistics:\nTwo point S_2 function\nCluster C_2 function\nSurface-surface F_ss function\nSurface-void F_sv function\nThree-point statistics:\nThree point S_3 function\nCluster C_3 function\nSurface-surface-surface F_sss function\nSurface-surface-void F_ssv function\nSurface-void-void F_svv function\nOther functions:\nPore size P function\nChord length p function\nLineal-path L_2 function","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Correlation functions based on two-point statistics can be calculated using two slightly different ways. The first way is to calculate them across several predefined directions (e.g. axial directions of an array). Another way is to build a correlation map, in other words to calculate a correlation function in all possible directions in a given array. The first way is implemented in CorrelationFunctions.Directional module and the second is implemented in CorrelationFunctions.Map module. Correlation functions based on three-point statistics are in the first module and are calculated in a selected set of points or using a right triangle pattern.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Here is a documentation for each of those modules and some helper functions.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Directional Functions. Correlation functions across predefined directions and functions based on three-point statistics.\nCorrelation Maps. Correlation maps or correlation functions in all directions.\nUtilities. Utility functions.","category":"page"},{"location":"directional.html#Directional-Functions","page":"Directional Functions","title":"Directional Functions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"This is a documentation for CorrelationFunctions.Directional module. The documentation is divided into the following topics:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Boundary Conditions page describes boundary conditions when calculations cross the boundary of a system.\nDirections page describes directions along which the correlation functions are computed.\nCorrelation Functions page contains the exhaustive list of correlation functions supported by this package.\nResults page contains comparison of correlation functions from this package with some known theoretical results.","category":"page"},{"location":"directional.html#Boundary-Conditions","page":"Directional Functions","title":"Boundary Conditions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Suppose you are calculating correlation functions for a sequence of length N. Calculation of a vast majority of the functions in this package can be reduced to a calculation of autocorrelation between two sequences, a and b:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"h_k = fracsumlimits_l=0^tildeN a_l b_k+ltildeN","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"where tildeN is a normalization factor. There are few boundary conditions which define which value tildeN can take. Here they are:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Periodic boundary conditions. In this case tildeN = N. Indexing to a and b is performed modulo N.\nNon-periodic boundary conditions. In this case tildeN_k = N - k.\nCalculations using a mask. In this case l runs not from 0 to tildeN, but can take only values allowed by a boolean mask, which must be of the same length as the input sequence (or, more generally, of the same shape as the input array).","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Boundary conditions are selected by a keyword argument mode. The mode is a value of the type AbstractMode. Constructors for descendants of that type are following:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Utilities.Periodic\nUtilities.NonPeriodic\nUtilities.Mask\nUtilities.AbstractMode","category":"page"},{"location":"directional.html#CorrelationFunctions.Utilities.Periodic","page":"Directional Functions","title":"CorrelationFunctions.Utilities.Periodic","text":"Periodic()\n\nPeriodic boundary conditions for image filtering and calculation of correlation functions.\n\nSee also: AbstractMode.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.NonPeriodic","page":"Directional Functions","title":"CorrelationFunctions.Utilities.NonPeriodic","text":"NonPeriodic()\n\nNon-periodic boundary conditions for image filtering and calculation of correlation functions.\n\nSee also: AbstractMode.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.Mask","page":"Directional Functions","title":"CorrelationFunctions.Utilities.Mask","text":"Mask(mask)\n\nCalculation mode using a mask. The mask must be a bit array of the same shape as an input array for a correlation function. The result of computations is of the same shape as for non-periodic mode. NaN elements of the result mean that there was not a single trial at that point.\n\nSee also: AbstractMode.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.AbstractMode","page":"Directional Functions","title":"CorrelationFunctions.Utilities.AbstractMode","text":"AbstractMode\n\nAbstract type to describe boundary conditions of calculation\n\nSee also: Periodic, NonPeriodic, Mask.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#Directions","page":"Directional Functions","title":"Directions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Functions based on two-point statistics from Directional module will require a direction along which the function is calculated (usually as their third argument). You can specify these directions:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Utilities.DirX\nUtilities.DirY\nUtilities.DirZ\nUtilities.DirXY\nUtilities.DirYX\nUtilities.DirXZ\nUtilities.DirZX\nUtilities.DirYZ\nUtilities.DirZY\nUtilities.DirXYZ\nUtilities.DirXZY\nUtilities.DirYXZ\nUtilities.DirZYX\nUtilities.AbstractDirection","category":"page"},{"location":"directional.html#CorrelationFunctions.Utilities.DirX","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirX","text":"DirX()\n\nA subtype of AbstractDirection Corresponds to vectors [1], [1, 0] or [1, 0, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirY","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirY","text":"DirY()\n\nA subtype of AbstractDirection Corresponds to vectors [0, 1] or [0, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirZ","text":"DirZ()\n\nA subtype of AbstractDirection Corresponds to a vector [0, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirXY","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirXY","text":"DirXY()\n\nA subtype of AbstractDirection Corresponds to vectors [1, 1] or [1, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirYX","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirYX","text":"DirYX()\n\nA subtype of AbstractDirection Corresponds to vectors [-1, 1] or [-1, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirXZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirXZ","text":"DirXZ()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirZX","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirZX","text":"DirZX()\n\nA subtype of AbstractDirection Corresponds to a vector [-1, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirYZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirYZ","text":"DirYZ()\n\nA subtype of AbstractDirection Corresponds to a vector [0, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirZY","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirZY","text":"DirZY()\n\nA subtype of AbstractDirection Corresponds to a vector [0, -1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirXYZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirXYZ","text":"DirXYZ()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirXZY","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirXZY","text":"DirXZY()\n\nA subtype of AbstractDirection Corresponds to a vector [1, -1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirYXZ","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirYXZ","text":"DirYXZ()\n\nA subtype of AbstractDirection Corresponds to a vector [-1, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.DirZYX","page":"Directional Functions","title":"CorrelationFunctions.Utilities.DirZYX","text":"DirZYX()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 1, -1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Utilities.AbstractDirection","page":"Directional Functions","title":"CorrelationFunctions.Utilities.AbstractDirection","text":"AbstractDirection\n\nAbstract type for direction vectors used in calculation of directional correlation functions. Each subtype of AbstractDirection corresponds with one 2D and/or one 3D vector along which slices are taken for calculation.\n\nSee also: DirX, DirY, DirZ, DirXY, DirYX, DirXZ, DirZX, DirYZ, DirZY, DirXYZ, DirXZY, DirYXZ, DirZYX.\n\n\n\n\n\n","category":"type"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The module Map can use these directions to extract directional information from correlation maps.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"These rules can help you to memoize the correspondence between symbolic designations and vectors:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"DirFoo types can contain from one to three characters X, Y and Z. Each character can occur only once (there is a type DirXYZ, but no type DirXXY).\nWhen a character does not occur is a designation (e.g, there is no Z in DirXY) that coordinate remains constant in a slice (in the example above z = textconst).\nThe names of the axes have a \"natural order\" which is X, Y, Z. In a designation, the first axis which breaks that order get the minus sign in the direction vector (e.g. DirXZY equals to (1, -1, 1) because Y is in the third position, not in the second, DirZX equals to (-1, 0, 1) because X is in the second position, not in the first, etc.)","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Functions based on three-point statistics require a set of points in which they are calculated (usually as the third and the fourth arguments). This set can be generated by Utilities.right_triangles function.","category":"page"},{"location":"directional.html#Correlation-Functions","page":"Directional Functions","title":"Correlation Functions","text":"","category":"section"},{"location":"directional.html#Two-point-statistics","page":"Directional Functions","title":"Two-point statistics","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.s2\nDirectional.c2\nDirectional.cross_correlation\nDirectional.surf2\nDirectional.surfvoid","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.s2","page":"Directional Functions","title":"CorrelationFunctions.Directional.s2","text":"s2(array, phase, direction[; len] [,mode = NonPeriodic()])\n\nCalculate S₂ (two point) correlation function for one-, two- or three-dimensional multiphase system.\n\nS₂(x) equals to probability that corner elements of a line segment with the length x cut from the array belong to the same phase. This implementation calculates S₂(x) for all xes in the range from 1 to len which defaults to half of the minimal dimenstion of the array.\n\nExamples\n\njulia> s2([1,1,1,0,1,1], 1, DirX(); len = 6)\n6-element Vector{Float64}:\n 0.8333333333333334\n 0.6\n 0.5\n 0.6666666666666666\n 1.0\n 1.0\n\nSee also: Utilities.AbstractDirection, Utilities.AbstractMode.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.c2","page":"Directional Functions","title":"CorrelationFunctions.Directional.c2","text":"c2(array, phase, direction[; len,] [mode = NonPeriodic])\n\nCalculate C₂ (cluster) correlation function for one-, two- or three-dimensional multiphase system.\n\nC₂(x) equals to probability that corner elements of a line segment with the length x cut from the array belong to the same cluster of the specific phase. This implementation calculates C2 for all xes in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nExamples\n\njulia> c2([1,1,1,0,1,1], 1, DirX(); len = 6)\n6-element Array{Float64,1}:\n 0.8333333333333333\n 0.5999999999999999\n 0.24999999999999994\n 2.4671622769447922e-17\n 9.25185853854297e-17\n 5.181040781584064e-16\n\nFor a list of possible directions, see also: Utilities.AbstractDirection, Utilities.AbstractMode.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.cross_correlation","page":"Directional Functions","title":"CorrelationFunctions.Directional.cross_correlation","text":"cross_correlation(array, phase1, phase2, direction[; len] [,mode = NonPeriodic()])\n\nCalculate cross-correlation between phase1 and phase2 in array. The meaning of optional arguments is the same as for s2 function.\n\nSee also: s2, Utilities.AbstractDirection, Utilities.AbstractMode.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surf2","page":"Directional Functions","title":"CorrelationFunctions.Directional.surf2","text":"surf2(array, phase, direction[; len] [,mode = NonPeriodic()][, filter])\n\nCalculate surface-surface correlation function for one-, two- or three-dimensional multiphase system. This implementation calculates surface-surface function for all xs in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nIf phase is a function it is applied to array to select the phase of interest, otherwise the phase of interest is selected by testing elements of array for equality with phase.\n\nSee also: Utilities.AbstractDirection, Utilities.AbstractMode, Utilities.AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surfvoid","page":"Directional Functions","title":"CorrelationFunctions.Directional.surfvoid","text":"surfvoid(array, phase, direction[; len] [, mode = NonPeriodic()][, filter])\n\nCalculate surface-void correlation function for one-, two- or three-dimensional multiphase system. This implementation calculates surface-void function for all xs in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nIf phase is a function it is applied to array to select the phase of interest, otherwise the phase of interest is selected by testing elements of array for equality with phase.\n\nVoid phase is assumed to be 0.\n\nSee also: Utilities.AbstractDirection, Utilities.AbstractMode, Utilities.AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#Three-point-statistics","page":"Directional Functions","title":"Three-point statistics","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.s3\nDirectional.c3\nDirectional.surf3\nDirectional.surf2void\nDirectional.surfvoid2","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.s3","page":"Directional Functions","title":"CorrelationFunctions.Directional.s3","text":"s3(array, ps1, ps2[, mode = NonPeriodic()])\n\nCalculate the three-point correlation function in an array of points.\n\nTwo arguments ps1 and ps2 must be arrays of N-tuples of integers (where N is a dimensionality of the input array) broadcastable to the same size. Periodic or zero-padding boundary conditions are selected with the choose of mode argument.\n\nThe following invariants hold:\n\njulia> data = rand(Bool, (100, 100, 100));\njulia> shiftsx = [(i, 0, 0) for i in 0:49];\njulia> shiftsy = [(0, i, 0) for i in 0:49];\njulia> shiftsz = [(0, 0, i) for i in 0:49];\njulia> s2x = D.s2(data, 1, U.DirX());\njulia> s2y = D.s2(data, 1, U.DirY());\njulia> s2z = D.s2(data, 1, U.DirZ());\njulia> s2x_ = D.s3(data, [(0,0,0)], shiftsx);\njulia> s2y_ = D.s3(data, [(0,0,0)], shiftsy);\njulia> s2z_ = D.s3(data, [(0,0,0)], shiftsz);\n\njulia> s2x == s2x_\ntrue\n\njulia> s2y == s2y_\ntrue\n\njulia> s2z == s2z_\ntrue\n\nSee also: right_triangles, s2.\n\n\n\n\n\ns3(array, phase, ps1, ps2[; mode = NonPeriodic()])\n\nThe same as s3(array .== phase; ...). Kept for consistency with other parts of the API.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.c3","page":"Directional Functions","title":"CorrelationFunctions.Directional.c3","text":"c3(array, phase[; planes :: Vector{AbstractPlane}, len, mode = NonPeriodic()])\n\nCalculate three-point cluster correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nSee also: s3, AbstractPlane.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surf3","page":"Directional Functions","title":"CorrelationFunctions.Directional.surf3","text":"surf3(array, ps1, ps2[; mode = NonPeriodic()][, filter :: AbstractKernel])\n\nCalculate surface-surface-surface (F_sss) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nSee also: s3, right_triangles, AbstractKernel.\n\n\n\n\n\nsurf3(array, phase[; mode = NonPeriodic()][, filter = ConvKernel(7)])\n\nThe same as surf3(array .== phase; ...). Kept for consistency with other parts of the API.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surf2void","page":"Directional Functions","title":"CorrelationFunctions.Directional.surf2void","text":"surf2void(array, phase, ps1, ps2[, void_phase = 0][; mode = NonPeriodic()][, filter :: AbstractKernel])\n\nCalculate surface-surface-void (F_ssv) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nSee also: s3, right_triangles, AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surfvoid2","page":"Directional Functions","title":"CorrelationFunctions.Directional.surfvoid2","text":"surfvoid2(array, phase, ps1, ps2[, void_phase = 0][; mode = NonPeriodic()][, filter :: AbstractKernel])\n\nCalculate surface-void-void (F_svv) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nSee also: s3, AbstractPlane, AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#Other-correlation-functions","page":"Directional Functions","title":"Other correlation functions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.pore_size\nDirectional.chord_length\nDirectional.l2","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.pore_size","page":"Directional Functions","title":"CorrelationFunctions.Directional.pore_size","text":"pore_size(array, phase = 0; mode = NonPeriodic())\n\nCalculate pore size correlation function for one-, two- or three-dimensional multiphase systems.\n\nThis implementation returns an array of pore sizes where each size is equal to the distance from a particular point in the pore to the closest point not belonging to the phase phase.\n\nExample\n\njulia> data = [1 1 1 1 1; 1 1 0 1 1; 1 0 0 0 1; 1 1 0 1 1; 1 1 1 1 1]\n5×5 Matrix{Int64}:\n 1  1  1  1  1\n 1  1  0  1  1\n 1  0  0  0  1\n 1  1  0  1  1\n 1  1  1  1  1\n\njulia> D.pore_size(data, 0)\n5-element Vector{Float64}:\n 1.0\n 1.0\n 1.4142135623730951\n 1.0\n 1.0\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.chord_length","page":"Directional Functions","title":"CorrelationFunctions.Directional.chord_length","text":"chord_length(array, phase, direction)\n\nCalculate the chord length correlation function for one-, two- or three-dimensional multiphase systems.\n\nA chord is a line segment which touches the boundary of a same-phase cluster with its ends.\n\nThis implementation returns an array of chord lengths where each length is equal to a number of voxels in the phase phase belonging to a chord.\n\nExamples\n\njulia> chord_length([1, 0, 0, 0, 0, 1, 0, 1], 0, DirX())\n2-element Vector{Int64}:\n 4\n 1\n\nFor a list of possible dimensions, see also: Utilities.AbstractDirection.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.l2","page":"Directional Functions","title":"CorrelationFunctions.Directional.l2","text":"l2(array, phase, direction[; len][, mode = NonPeriodic()])\n\nCalculate L₂ (lineal path) correlation function for one-, two- or three-dimensional multiphase system.\n\nL₂(x) equals to probability that all elements of a line segment with length x cut from the array belong to the same phase. This implementation calculates L₂(x) for all xes in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nExamples\n\njulia> l2([1,1,1,0,1,1], 1, DirX(); len = 6)\n6-element Array{Float64,1}:\n 0.8333333333333334\n 0.6\n 0.25\n 0.0\n 0.0\n 0.0\n\nFor a list of possible dimensions, see also: Utilities.AbstractDirection, [Utilities.AbstractMode])(@ref).\n\n\n\n\n\n","category":"function"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The pore_size function is also reexported from CorrelationFunctions directly, not being actually a \"directional\" function.","category":"page"},{"location":"directional.html#Results","page":"Directional Functions","title":"Results","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"CorrelationFunctions.jl is tested on overlapping disks and balls of constant radius R with centers generated by Poisson process with parameter lambda (see section 5.1 of Random Heterogeneous Materials). An example of a two-dimensional two-phase system generated in this way is on the picture (R = 25 and lambda = 5 cdot 10^-4):","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"(Image: disks)","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Plots of all correlation functions calculated by CorrelationFunctions.jl for overlapping disks along with their theoretical values are given below. There are also plots of relative errors calculated as","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"texterr(x) = mid fractextcalculation(x) -\ntexttheory(x)texttheory(x) mid","category":"page"},{"location":"directional.html#Two-dimensional-systems","page":"Directional Functions","title":"Two-dimensional systems","text":"","category":"section"},{"location":"directional.html#Methodology","page":"Directional Functions","title":"Methodology","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"All functions in this section with exception of pore size and chord length functions are calculated on 15 random datasets generated with parameters R = 25 and lambda = 5 cdot 10^-4. Each dataset is an image with dimensions 4000x4000 pixels. The final result is an average of results on those 15 datasets. When function fastly decreases to zero a plot of a natural logarithm of that function is provided.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size and chord length functions are calculated on one 4000x4000 dataset with the same parameters as above. A theoretical value is computed by averaging a theoretical function across each bin of a histogram returned by pore_size or chord_length function. Because both pore size and cord length functions decrease to zero with increase of their arguments, the relative errors are calculated for the corresponding cummulative distribution functions.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"All functions are called with default optional arguments unless explicitly stated otherwise.","category":"page"},{"location":"directional.html#Two-point-S_2(x)-function","page":"Directional Functions","title":"Two point S_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"S2 Error\n(Image: s2) (Image: s2 error)","category":"page"},{"location":"directional.html#Lineal-path-L_2(x)-function","page":"Directional Functions","title":"Lineal path L_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"L2 Error\n(Image: l2) (Image: l2 error)","category":"page"},{"location":"directional.html#Surface-surface-F_{ss}(x)-function","page":"Directional Functions","title":"Surface-surface F_ss(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-surface Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Surface-void-F_{sv}(x)-function","page":"Directional Functions","title":"Surface-void F_sv(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-void Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Pore-size-P(x)-function","page":"Directional Functions","title":"Pore size P(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Chord-length-p(x)-function","page":"Directional Functions","title":"Chord length p(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length function chord_length was called with parameter nbins = 30.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Three-dimensional-systems","page":"Directional Functions","title":"Three-dimensional systems","text":"","category":"section"},{"location":"directional.html#Methodology-2","page":"Directional Functions","title":"Methodology","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The idea is the same as in two-dimensional case, but chosen parameters are slightly different. The functions are averaged over 5 500x500x500 datasets with ball radius R = 20 and Poisson process parameter lambda = 3 cdot 10^-5.","category":"page"},{"location":"directional.html#Two-point-S_2(x)-function-2","page":"Directional Functions","title":"Two point S_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"S2 Error\n(Image: s2) (Image: s2 error)","category":"page"},{"location":"directional.html#Lineal-path-L_2(x)-function-2","page":"Directional Functions","title":"Lineal path L_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"L2 Error\n(Image: l2) (Image: l2 error)","category":"page"},{"location":"directional.html#Surface-surface-F_{ss}(x)-function-2","page":"Directional Functions","title":"Surface-surface F_ss(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-surface Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Surface-void-F_{sv}(x)-function-2","page":"Directional Functions","title":"Surface-void F_sv(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-void Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Pore-size-P(x)-function-2","page":"Directional Functions","title":"Pore size P(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Chord-length-p(x)-function-2","page":"Directional Functions","title":"Chord length p(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length function chord_length was called with parameter nbins = 30.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length Error\n(Image: ss) (Image: ss error)","category":"page"}]
}
