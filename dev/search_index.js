var documenterSearchIndex = {"docs":
[{"location":"higher-order.html#Higher-order-statistics","page":"Higher order statistics","title":"Higher order statistics","text":"","category":"section"},{"location":"higher-order.html","page":"Higher order statistics","title":"Higher order statistics","text":"Since version 0.9 CorrelationFunctions.jl has a support for higher order correlation functions. These functions are placed in the CorrelationFunctions.Directional module. There is no support for higher order correlation maps because such maps consume a large amount of memory.","category":"page"},{"location":"higher-order.html#Patterns-and-planes","page":"Higher order statistics","title":"Patterns and planes","text":"","category":"section"},{"location":"higher-order.html","page":"Higher order statistics","title":"Higher order statistics","text":"Currently these functions sample an input array with a pattern in the form of a right triangle parallel to one of coordinate planes. Here is a description of the planes:","category":"page"},{"location":"higher-order.html","page":"Higher order statistics","title":"Higher order statistics","text":"Directional.AbstractPlane\nDirectional.PlaneXY\nDirectional.PlaneXZ\nDirectional.PlaneYZ","category":"page"},{"location":"higher-order.html#CorrelationFunctions.Directional.AbstractPlane","page":"Higher order statistics","title":"CorrelationFunctions.Directional.AbstractPlane","text":"AbstractPlane\n\nSubtypes of AbstractPlane serve as a plane designators for three-point correlation functions.\n\nSee also: PlaneXY, PlaneXZ, PlaneYZ, s3.\n\n\n\n\n\n","category":"type"},{"location":"higher-order.html#CorrelationFunctions.Directional.PlaneXY","page":"Higher order statistics","title":"CorrelationFunctions.Directional.PlaneXY","text":"PlaneXY()\n\nA designator for a plane defined by vectors [1, 0] and [0, 1] (2D case) or [1, 0, 0] and [0, 1, 0] (3D case).\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"higher-order.html#CorrelationFunctions.Directional.PlaneXZ","page":"Higher order statistics","title":"CorrelationFunctions.Directional.PlaneXZ","text":"PlaneXZ()\n\nA designator for a plane defined by vectors [1, 0, 0] and [0, 0, 1].\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"higher-order.html#CorrelationFunctions.Directional.PlaneYZ","page":"Higher order statistics","title":"CorrelationFunctions.Directional.PlaneYZ","text":"PlaneYZ()\n\nA designator for a plane defined by vectors [0, 1, 0] and [0, 0, 1].\n\nSee also: AbstractPlane.\n\n\n\n\n\n","category":"type"},{"location":"higher-order.html#Correlation-functions","page":"Higher order statistics","title":"Correlation functions","text":"","category":"section"},{"location":"higher-order.html","page":"Higher order statistics","title":"Higher order statistics","text":"This section describes higher order correlation functions.","category":"page"},{"location":"higher-order.html","page":"Higher order statistics","title":"Higher order statistics","text":"Directional.s3\nDirectional.c3\nDirectional.surf3\nDirectional.surf2void\nDirectional.surfvoid2","category":"page"},{"location":"higher-order.html#CorrelationFunctions.Directional.s3","page":"Higher order statistics","title":"CorrelationFunctions.Directional.s3","text":"s3(array[; planes :: Vector{AbstractPlane}, len, periodic = false])\n\nCalculate the three-point correlation function using a right triangle pattern.\n\nThis function takes an array and a vector of planes parallel to axes of the array. For each plane all possible right triangles with length of a side ≤ len and parallel to that plane are generated and tested against the array. A dictionary of type Dict{AbstractPlane, Matrix{Float64}} is returned as a result. Indices of arrays equal to lengths of catheti of a right triangle. Periodic or zero-padding boundary conditions are selected with the choose of periodic argument.\n\nThe following invariants hold:\n\njulia> array = rand(Bool, (100, 100));\njulia> vals2 = s2(array, 1);\njulia> vals3 = s3(array);\njulia> vals2[DirX()] == vals3[PlaneXY][:, 1]\ntrue\njulia> vals2[DirY()] == vals3[PlaneXY][1, :]\ntrue\n\nThe same is true for other planes.\n\nSee also: AbstractPlane, s2.\n\n\n\n\n\ns3(array, phase[; planes :: Vector{AbstractPlane}, len, periodic = false])\n\nThe same as s3(array .== phase; ...). Kept for consistency with other parts of the API.\n\n\n\n\n\n","category":"function"},{"location":"higher-order.html#CorrelationFunctions.Directional.c3","page":"Higher order statistics","title":"CorrelationFunctions.Directional.c3","text":"c3(array, phase[; planes :: Vector{AbstractPlane}, len, periodic = false])\n\nCalculate three-point cluster correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nSee also: s3, AbstractPlane.\n\n\n\n\n\n","category":"function"},{"location":"higher-order.html#CorrelationFunctions.Directional.surf3","page":"Higher order statistics","title":"CorrelationFunctions.Directional.surf3","text":"surf3(array, phase[; planes :: Vector{AbstractPlane},\n                     len, periodic = false, filter :: AbstractKernel])\n\nCalculate surface-surface-surface (F_sss) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.ErosionKernel.\n\nSee also: s3, AbstractPlane, ErosionKernel.\n\n\n\n\n\n","category":"function"},{"location":"higher-order.html#CorrelationFunctions.Directional.surf2void","page":"Higher order statistics","title":"CorrelationFunctions.Directional.surf2void","text":"surf2void(array, phase[; void_phase = 0,\n        planes :: Vector{AbstractPlane}, len, periodic = false, filter :: AbstractKernel])\n\nCalculate surface-surface-void (F_ssv) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format. The first index in the resulting arrays is responsible for the \"void part\" of the functions and the second is responsible for the \"surface part\".\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.ErosionKernel.\n\nSee also: s3, AbstractPlane, ErosionKernel.\n\n\n\n\n\n","category":"function"},{"location":"higher-order.html#CorrelationFunctions.Directional.surfvoid2","page":"Higher order statistics","title":"CorrelationFunctions.Directional.surfvoid2","text":"surfvoid2(array, phase[; void_phase = 0,\n        planes :: Vector{AbstractPlane}, len, periodic = false, filter :: AbstractKernel])\n\nCalculate surface-void-void (F_svv) correlation function.\n\nThis function is is internally calculated using s3 and hence uses the same sampling pattern and returns a result in the same format.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.ErosionKernel.\n\nSee also: s3, AbstractPlane, ErosionKernel.\n\n\n\n\n\n","category":"function"},{"location":"maps.html#Correlation-Maps","page":"Correlation Maps","title":"Correlation Maps","text":"","category":"section"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"The module CorrelationFunctions.Map contains functions which calculate correlation maps, i.e. correlation functions over all possible directions with all possible correlation lengths.","category":"page"},{"location":"maps.html#Functions","page":"Correlation Maps","title":"Functions","text":"","category":"section"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"The following correlation functions are supported:","category":"page"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"Two point S_2 function.\nCluster C_2 function.\nSurface-surface F_ss function.\nSurface-void F_sv function.","category":"page"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"Map.c2\nMap.s2\nMap.cross_correlation\nMap.surf2\nMap.surfvoid\nMap.average_directions","category":"page"},{"location":"maps.html#CorrelationFunctions.Map.c2","page":"Correlation Maps","title":"CorrelationFunctions.Map.c2","text":"c2(image, phase; periodic = false)\n\nCalculate C_2 (cluster) correlation function for the phase phase in an N-dimensional image.\n\nExamples\n\njulia> c2([1 0; 0 1], 1; periodic=true)\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.s2","page":"Correlation Maps","title":"CorrelationFunctions.Map.s2","text":"s2(image; periodic = false)\n\nCalculate S_2 (two point) correlation function for the binary image image.\n\n\n\n\n\ns2(image, phase; periodic = false)\n\nCalculate S_2 (two point) correlation function for the phase phase in an N-dimensional image.\n\nExamples\n\njulia> s2([1 0; 0 1], 1; periodic=true)\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.cross_correlation","page":"Correlation Maps","title":"CorrelationFunctions.Map.cross_correlation","text":"cross_correlation(image1, image2; periodic = false)\n\nCalculate cross-correlation function between binary images image1 and image2.\n\n\n\n\n\ncross_correlation(image, p1, p2; periodic = false)\n\nCalculate cross-correlation function between phases p1 and p2 in an N-dimensional image.\n\nExamples\n\njulia> cross_correlation([1 0; 0 1], 1, 0; periodic=true)\n2×2 Matrix{Float64}:\n 0.0  0.5\n 0.5  0.0\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.surf2","page":"Correlation Maps","title":"CorrelationFunctions.Map.surf2","text":"surf2(image, phase; periodic = false, filter)\n\nCalculate F_ss (surface-surface) correlation function for phase phase on N-dimensional image.\n\nExamples\n\njulia> surf2([1 0; 0 1], 1; periodic=true)\n2×2 Matrix{Float64}:\n 0.125  0.125\n 0.125  0.125\n\nSee also: Utilities.AbstractKernel\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.surfvoid","page":"Correlation Maps","title":"CorrelationFunctions.Map.surfvoid","text":"surfvoid(image, phase; periodic = false, filter)\n\nCalculate F_sv (surface-void) correlation function for phase phase on N-dimensional image. Phase 0 is considered to be void.\n\nExamples\n\njulia> surfvoid([1 0; 0 1], 1; periodic=true)\n2×2 Matrix{Float64}:\n 0.5  0.5\n 0.5  0.5\n\nSee also: Utilities.AbstractKernel\n\n\n\n\n\n","category":"function"},{"location":"maps.html#CorrelationFunctions.Map.average_directions","page":"Correlation Maps","title":"CorrelationFunctions.Map.average_directions","text":"average_directions(cfmap; len = (cfmap |> size |> minimum) ÷ 2)\n\nAverage correlation map cfmap over all directions. The result is a vector of length len with indices being equal to correlation length + 1.\n\n\n\n\n\n","category":"function"},{"location":"maps.html","page":"Correlation Maps","title":"Correlation Maps","text":"You can use usual arrays (of type Array) or CUDA arrays for these functions.","category":"page"},{"location":"utilities.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities.html#Available-directions","page":"Utilities","title":"Available directions","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"The module Directional computes correlation functions in many directions depending on how test line segments are aligned with the input array. The default directions are [DirX()] for 1D, [DirX(), DirY()] for 2D and [DirX(), DirY(), DirZ()] for 3D arrays. Possible directions and their meaning are described below.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.DirX\nUtilities.DirY\nUtilities.DirZ\nUtilities.DirXY\nUtilities.DirYX\nUtilities.DirXZ\nUtilities.DirZX\nUtilities.DirYZ\nUtilities.DirZY\nUtilities.DirXYZ\nUtilities.DirXZY\nUtilities.DirYXZ\nUtilities.DirZYX\nUtilities.AbstractDirection\nUtilities.default_directions","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirX","page":"Utilities","title":"CorrelationFunctions.Utilities.DirX","text":"DirX()\n\nA subtype of AbstractDirection Corresponds to vectors [1], [1, 0] or [1, 0, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirY","page":"Utilities","title":"CorrelationFunctions.Utilities.DirY","text":"DirY()\n\nA subtype of AbstractDirection Corresponds to vectors [0, 1] or [0, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirZ","page":"Utilities","title":"CorrelationFunctions.Utilities.DirZ","text":"DirZ()\n\nA subtype of AbstractDirection Corresponds to a vector [0, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirXY","page":"Utilities","title":"CorrelationFunctions.Utilities.DirXY","text":"DirXY()\n\nA subtype of AbstractDirection Corresponds to vectors [1, 1] or [1, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirYX","page":"Utilities","title":"CorrelationFunctions.Utilities.DirYX","text":"DirYX()\n\nA subtype of AbstractDirection Corresponds to vectors [-1, 1] or [-1, 1, 0].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirXZ","page":"Utilities","title":"CorrelationFunctions.Utilities.DirXZ","text":"DirXZ()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirZX","page":"Utilities","title":"CorrelationFunctions.Utilities.DirZX","text":"DirZX()\n\nA subtype of AbstractDirection Corresponds to a vector [-1, 0, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirYZ","page":"Utilities","title":"CorrelationFunctions.Utilities.DirYZ","text":"DirYZ()\n\nA subtype of AbstractDirection Corresponds to a vector [0, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirZY","page":"Utilities","title":"CorrelationFunctions.Utilities.DirZY","text":"DirZY()\n\nA subtype of AbstractDirection Corresponds to a vector [0, -1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirXYZ","page":"Utilities","title":"CorrelationFunctions.Utilities.DirXYZ","text":"DirXYZ()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirXZY","page":"Utilities","title":"CorrelationFunctions.Utilities.DirXZY","text":"DirXZY()\n\nA subtype of AbstractDirection Corresponds to a vector [1, -1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirYXZ","page":"Utilities","title":"CorrelationFunctions.Utilities.DirYXZ","text":"DirYXZ()\n\nA subtype of AbstractDirection Corresponds to a vector [-1, 1, 1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.DirZYX","page":"Utilities","title":"CorrelationFunctions.Utilities.DirZYX","text":"DirZYX()\n\nA subtype of AbstractDirection Corresponds to a vector [1, 1, -1].\n\nSee also: AbstractDirection.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.AbstractDirection","page":"Utilities","title":"CorrelationFunctions.Utilities.AbstractDirection","text":"AbstractDirection\n\nAbstract type for direction vectors used in calculation of directional correlation functions. Each subtype of AbstractDirection corresponds with one 2D and/or one 3D vector along which slices are taken for calculation.\n\nSee also: DirX, DirY, DirZ, DirXY, DirYX, DirXZ, DirZX, DirYZ, DirZY, DirXYZ, DirXZY, DirYXZ, DirZYX.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.default_directions","page":"Utilities","title":"CorrelationFunctions.Utilities.default_directions","text":"default_directions(array)\n\nGet default direction in which correlation functions are calculated for the given array.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"The module Map can use these types to extract directional information from correlation maps.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"These rules can help you to memoize the correspondence between symbolic designations and vectors:","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"DirFoo types can contain from one to three characters X, Y and Z. Each character can occur only once (there is a type DirXYZ, but no type DirXXY).\nWhen a character does not occur is a designation (e.g, there is no Z in DirXY) that coordinate remains constant in a slice (in the example above z = textconst).\nThe names of the axes have a \"natural order\" which is X, Y, Z. In a designation the first axis which breaks that order get the minus sign in the direction vector (e.g. DirXZY equals to (1, -1, 1) because Y is in the third position, not in the second, DirZX equals to (-1, 0, 1) because X is in the second position, not in the first, etc.)","category":"page"},{"location":"utilities.html#Edge-detection","page":"Utilities","title":"Edge detection","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"The function extract_edges complements imfilter from Images.jl and can be used to extract edges from an image on CPU and GPU.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.extract_edges\nUtilities.AbstractTopology\nUtilities.Plane\nUtilities.Torus\nUtilities.AbstractKernel\nUtilities.ConvKernel\nUtilities.ErosionKernel","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.extract_edges","page":"Utilities","title":"CorrelationFunctions.Utilities.extract_edges","text":"extract_edges(array, filter, topology)\n\nPerform edge extraction in the same way as in surfsurf and surfvoid functions from Map and Directional modules. array may be a CUDA array or an ordinary array. filter is a value of AbstractKernel type which selects an edge extraction algorithm. Boundary conditions are affected by topology. Periodic boundary conditions are assumed if topology is Torus() and reflection from the boundaries is used if topology is Plane().\n\nSee also: AbstractKernel, AbstractTopology.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.AbstractTopology","page":"Utilities","title":"CorrelationFunctions.Utilities.AbstractTopology","text":"AbstractTopology\n\nAbstract type for describing topology of an input array.\n\nSee also: Plane, Torus.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.Plane","page":"Utilities","title":"CorrelationFunctions.Utilities.Plane","text":"Plane()\n\nTopology for calculation of correlation functions in non-periodic mode. Usually this means zero-padding of an input for out-of-bounds array access.\n\nNB: When extracting edges with Plane topology, reflection from array borders is used for out-of-bounds access. Although, it's natural to assume zero padding must be used, we want an equality F_ss^(false) = F_ss^(true) for two-phase system, hence we cannot pad the input with some constant value.\n\nSee also: AbstractTopology.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.Torus","page":"Utilities","title":"CorrelationFunctions.Utilities.Torus","text":"Torus()\n\nTopology for calculation of correlation functions in periodic mode. An input is extended to the infinity periodically as if it was wrapped around a torus.\n\nSee also: AbstractTopology.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.AbstractKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.AbstractKernel","text":"AbstractKernel\n\nAbstract type for one of edge detecting filters.\n\nSee also: ConvKernel, ErosionKernel.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.ConvKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.ConvKernel","text":"ConvKernel(n)\n\nConvolution kernel of width n used in edge detection. Values 5 and 7 are possible values for n. Using n = 7 works best for the most cases (lowfreq_energy_ratio(array) > 0.97).\n\nSee also: AbstractKernel, extract_edges.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#CorrelationFunctions.Utilities.ErosionKernel","page":"Utilities","title":"CorrelationFunctions.Utilities.ErosionKernel","text":"ErosionKernel(n)\n\nErosion kernel of width n used in edge detection. Used in three-point surface correlation functions.\n\nSee also: AbstractKernel, extract_edges.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#Misc","page":"Utilities","title":"Misc","text":"","category":"section"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Some miscellaneous functions and helpers.","category":"page"},{"location":"utilities.html","page":"Utilities","title":"Utilities","text":"Utilities.read_cuboid\nUtilities.lowfreq_energy_ratio\nUtilities.make_rotation\nUtilities.rotate_array","category":"page"},{"location":"utilities.html#CorrelationFunctions.Utilities.read_cuboid","page":"Utilities","title":"CorrelationFunctions.Utilities.read_cuboid","text":"read_cuboid(cfgpath :: String)\n\nRead 3D array from a disk. The data on disk consists of two files: JSON configuration file (which is passed to this function) and a raw binary array data.\n\nScheme of the configuration file is as follows, where x, y and z are dimensions of the array:\n\n{\n    \"dimensions\": [x, y, z],\n    \"datapath\": \"file-with-data\"\n}\n\nThe file with binary data, whose name is specified in datapath field, is searched relatively to the directory with the JSON configuration file. Its size must be exactly x⋅y⋅z bytes, each byte containing an element of the resulting array.\n\n\n\n\n\nread_cuboid(datapath :: String, side, dim)\n\nRead 3D array from a disk. The data on the disk must be in binary format, one octet per sample. Totally, there must be side^dim octets which are read into side times side times dots times side array.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.lowfreq_energy_ratio","page":"Utilities","title":"CorrelationFunctions.Utilities.lowfreq_energy_ratio","text":"lowfreq_energy_ratio(array, fraction = 0.5)\n\nCalculate a ratio E_aE where E is a total energy of a signal array and E_a is the energy concentrated in frequencies 0 af2 where f is the sampling rate and a is set via parameter fraction. mean(array) is subtracted from the array before calculations.\n\nThis function can be helpful in estimating if array is suitable for calculating surface-surface or surface-void function. An empirical criterion is that if this function returns a value greater than 0.97, the array is good.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.make_rotation","page":"Utilities","title":"CorrelationFunctions.Utilities.make_rotation","text":"make_rotation(ϕ)\n\nMake a rotation of 2-dimensional data by ϕ radians clockwise.\n\nSee also: rotate_array.\n\n\n\n\n\nmake_rotation(vec :: SVector{3}, ϕ)\n\nMake a rotation of 3-dimensional data by ϕ radians around a vector vec clockwise.\n\nSee also: rotate_array.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#CorrelationFunctions.Utilities.rotate_array","page":"Utilities","title":"CorrelationFunctions.Utilities.rotate_array","text":"rotate_array(array, rot, topology)\n\nRotate an array using rotation defined by rot. The coordinate system's origin is placed into the center of the array. Out-of-bounds array access is specified by topology argument. It is periodic extension of the array if topology is Torus() and zero padding if topology is Plane().\n\nSee also: AbstractTopology, Torus, Plane, make_rotation.\n\n\n\n\n\n","category":"function"},{"location":"index.html#CorrelationFunctions.jl","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"","category":"section"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"This package is a collection of correlation functions described in Salvatore Torquato's book \"Random Heterogeneous Materials\" ISBN 978-1-4757-6357-7. These functions can be calculated for one-, two- or three-dimensional multiphase systems using closed walls (CW) or periodic boundary conditions (PBC) along multiple directions.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Correlation functions can be calculated using two slightly different ways. The first way is to calculate them across several predefined directions (e.g. axial directions of an array). Another way is to build a correlation map, in other words to calculate a correlation function in all possible directions in a given array. The first way is implemented in CorrelationFunctions.Directional module and the second is implemented in CorrelationFunctions.Map module.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Here is a documentation for each of those modules and some helper functions.","category":"page"},{"location":"index.html","page":"CorrelationFunctions.jl","title":"CorrelationFunctions.jl","text":"Directional Functions. Correlation functions across predefined directions.\nCorrelation Maps. Correlation maps or correlation functions in all directions.\nUtilities. Utility functions.\nHigher order statistics. Three-point correlation functions.","category":"page"},{"location":"directional.html#Directional-Functions","page":"Directional Functions","title":"Directional Functions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"This is a documentation for CorrelationFunctions.Directional module. The documentation is divided into the following topics:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Correlation Functions page contains the exhaustive list of correlation functions supported by this package.\nAccessing Data page describes how to access data returned by correlation functions.\nBoundary Conditions page describes boundary conditions when calculations cross the boundary of a system.\nDirections page describes directions along which the correlation functions are computed.\nIndicator Functions page describes how to construct customary indicator functions.\nResults page contains comparison of correlation functions from this package with some known theoretical results.","category":"page"},{"location":"directional.html#Correlation-Functions","page":"Directional Functions","title":"Correlation Functions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The following correlation functions are supported:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Lineal-path L_2 function.\nTwo point S_2 function.\nCluster C_2 function.\nSurface-surface F_ss function.\nSurface-void F_sv function.\nPore size P function.\nChord length p function.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.l2\nDirectional.s2\nDirectional.c2\nDirectional.cross_correlation\nDirectional.surf2\nDirectional.surfvoid\nDirectional.pore_size\nDirectional.chord_length","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.l2","page":"Directional Functions","title":"CorrelationFunctions.Directional.l2","text":"l2(array, phase; [len][, directions,] periodic = false)\n\nCalculate L₂ (lineal path) correlation function for one-, two- or three-dimensional multiphase system.\n\nL₂(x) equals to probability that all elements of a line segment with length x cut from the array belong to the same phase. This implementation calculates L₂(x) for all xes in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nExamples\n\njulia> l2([1,1,1,0,1,1], 1; len = 6)[DirX()]\n6-element Array{Float64,1}:\n 0.8333333333333334\n 0.6\n 0.25\n 0.0\n 0.0\n 0.0\n\nFor a list of possible dimensions, see also: Utilities.AbstractDirection.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.s2","page":"Directional Functions","title":"CorrelationFunctions.Directional.s2","text":"s2(array, phase[; len][, plans][, directions,] periodic = false)\ns2(array, SeparableIndicator(χ₁, χ₂)[; len][, plans][,directions,] periodic = false)\ns2(array, InseparableIndicator(χ)[; len][,directions,] periodic = false)\n\nCalculate S₂ (two point) correlation function for one-, two- or three-dimensional multiphase system.\n\nS₂(x) equals to probability that corner elements of a line segment with the length x cut from the array belong to the same phase. This implementation calculates S₂(x) for all xes in the range from 1 to len which defaults to half of the minimal dimenstion of the array.\n\nMore generally, you can provide indicator function χ instead of phase. In this case S₂ function calculates probability of χ(x, y) returing true where x and y are two corners of a line segment. Indicator functions must be wrapped in either SeparableIndicator or InseparableIndicator. Some computations for separable indicator functions are optimized.\n\nAn argument plans can be used to support precomputed FFT plans which can be helpful if you call s2 often with the array of the same size. Plans can be computed with S2FTPlans constructor.\n\nExamples\n\njulia> s2([1,1,1,0,1,1], 1; len = 6)[DirX()]\n6-element Array{Float64,1}:\n 0.8333333333333334\n 0.6\n 0.5\n 0.6666666666666666\n 1.0\n 1.0\n\nSee also: Utilities.AbstractDirection, SeparableIndicator, InseparableIndicator, S2FTPlans.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.c2","page":"Directional Functions","title":"CorrelationFunctions.Directional.c2","text":"c2(array, phase[; len,][directions,] periodic = false)\n\nCalculate C₂ (cluster) correlation function for one-, two- or three-dimensional multiphase system.\n\nC₂(x) equals to probability that corner elements of a line segment with the length x cut from the array belong to the same cluster of the specific phase. This implementation calculates C2 for all xes in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nExamples\n\njulia> c2([1,1,1,0,1,1], 1; len = 6)[DirX()]\n6-element Array{Float64,1}:\n 0.8333333333333334\n 0.6\n 0.25\n 0.0\n 0.0\n 0.0\n\nFor a list of possible dimensions, see also: Utilities.AbstractDirection.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.cross_correlation","page":"Directional Functions","title":"CorrelationFunctions.Directional.cross_correlation","text":"cross_correlation(array, phase1, phase2[; len][, plans][, directions,] periodic = false)\n\nCalculate cross-correlation between phase1 and phase2 in array. The meaning of optional arguments is the same as for s2 function.\n\nSee also: s2.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surf2","page":"Directional Functions","title":"CorrelationFunctions.Directional.surf2","text":"surf2(array, phase[; len][, directions][, plans,] periodic = false, filter)\n\nCalculate surface-surface correlation function for one-, two- or three-dimensional multiphase system.\n\nSurface-surface CF equals to probability that corner elements of a line segment with the length x cut from the array belong to the boundary of a cluster with the phase phase. This implementation calculates surface-surface function for all xs in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nIf phase is a function it is applied to array to select the phase of interest, otherwise the phase of interest is selected by testing elements of array for equality with phase.\n\nAn argument plans can be used to support precomputed FFT plans which can be helpful if you call surf2 often with the array of the same size. Plans can be computed with S2FTPlans constructor.\n\nSee also: Utilities.AbstractDirection, S2FTPlans, Utilities.AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.surfvoid","page":"Directional Functions","title":"CorrelationFunctions.Directional.surfvoid","text":"surfvoid(array, phase[; len][, directions][, plans,] void_phase = 0, periodic = false, filter)\n\nCalculate surface-void correlation function for one-, two- or three-dimensional multiphase system.\n\nSurface-void CF equals to probability that one corner of a line segment with the length x cut from the array belongs to the boundary of a cluster with the phase phase and the other belongs to the void phase 0. This implementation calculates surface-void function for all xs in the range from 1 to len which defaults to half of the minimal dimension of the array.\n\nYou can chose how an edge between phases is selected by passing filter argument of type Utilities.AbstractKernel.\n\nIf phase is a function it is applied to array to select the phase of interest, otherwise the phase of interest is selected by testing elements of array for equality with phase. void_phase can also be either a function or some other object and is used as an indicator for the void phase.\n\nAn argument plans can be used to support precomputed FFT plans which can be helpful if you call surfvoid often with the array of the same size. Plans can be computed with S2FTPlans constructor.\n\nSee also: Utilities.AbstractDirection, S2FTPlans, Utilities.AbstractKernel.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.pore_size","page":"Directional Functions","title":"CorrelationFunctions.Directional.pore_size","text":"pore_size(array, phase = 0; nbins = 10, periodic = false)\n\nCalculate pore size correlation function for one-, two- or three-dimensional multiphase system.\n\nPore size correlation function P(x) equals to probability of inserting a ball with radius R ∈ [x, x + δx] into a system so that it lies entirely in the phase phase.\n\nThis implementation divides the range of possible radii into nbins subranges and returns a normalized histogram of radii. This is roughly equal to integrating P(x) for each subrange.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#CorrelationFunctions.Directional.chord_length","page":"Directional Functions","title":"CorrelationFunctions.Directional.chord_length","text":"chord_length(array, phase[; directions,] nbins = 10)\n\nCalculate chord length correlation function for one-, two- or three-dimensional multiphase system.\n\nCord length function p(x) equals to probability of finding a chord whose length is in the range [x, x+δx] and which lies entirely in the phase phase. A chord is a line segment which touches the boundary of a same-phase cluster with its ends.\n\nThis implementation bins chord lengths into nbins bins and returns normalized histogram on collected data along with mean chord length and standard deviation.\n\nExamples\n\njulia> chord_length([1, 0, 0, 0, 0, 1, 0, 1], 0)\nChord length info (mean = 2.5, std = 2.1213203435596424)\n\nFor a list of possible dimensions, see also: Utilities.AbstractDirection.\n\n\n\n\n\n","category":"function"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The pore_size function is also reexported from CorrelationFunctions directly, not being actually a \"directional\" function.","category":"page"},{"location":"directional.html#Accessing-Data","page":"Directional Functions","title":"Accessing Data","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The most functions in this package (with exception to pore_size and chord_length) return a value of type CorrelationData:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"using CorrelationFunctions.Directional\nusing Random\n\na = l2(rand(MersenneTwister(1453), 0:1, (100, 100, 100)), 1)","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"CorrelationData implements AbstractDict interface. For example, you can extract the values along any computed direction using indexing operator:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"import CorrelationFunctions.Directional as D\nimport CorrelationFunctions.Utilities as U\nusing Random\n\na = D.l2(rand(MersenneTwister(1453), 0:1, (100, 100, 100)), 1)\na[U.DirY()]","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Also you can average results along multiple directions using Statistics.mean function:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"import CorrelationFunctions.Directional as D\nimport CorrelationFunctions.Utilities as U\nusing Random\nusing Statistics\n\na = D.l2(rand(MersenneTwister(1453), 0:1, (100, 100, 100)), 1)\nmean(a, [U.DirX(), U.DirY()])","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Calling Statistics.mean without the second argument averages along all computed directions.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.correlation_length","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.correlation_length","page":"Directional Functions","title":"CorrelationFunctions.Directional.correlation_length","text":"correlation_length(cd :: CorrelationData)\n\nReturn length of correlation vectors stored in cd.\n\n\n\n\n\n","category":"function"},{"location":"directional.html#Boundary-Conditions","page":"Directional Functions","title":"Boundary Conditions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"When calculating the value of correlation functions like S_2 or L_2 it may be necessary to cross a boundary of the input array. There two options how CorrelationFunctions.jl handles this situation:","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Impose \"closed walls\" (CW) boundary conditions on the input data. This means that the boundary is not crossed and correlation functions gather less statistics for bigger length of test line segments.\nImpose periodic boundary conditions (PBC) on the input data. This means that the input is wrapped around itself (i.e. modular arithmetic is used to access the array).","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"PBC is used when you specify periodic = true when call a correlation function, otherwise CW is used.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.S2FTPlans","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.S2FTPlans","page":"Directional Functions","title":"CorrelationFunctions.Directional.S2FTPlans","text":"S2FTPlans(array, Plane())\nS2FTPlans(array, Torus())\n\nCreate FFT plans for faster calculation of two-point, surface-surface and surface-void  correlation functions. Plane() corresponds to CW boundary conditions and Torus() corresponds to periodic boundary conditions.\n\nSee also: s2, surf2, surfvoid.\n\n\n\n\n\nS2FTPlans(array, periodic)\n\nCreate FFT plans for faster calculation of two-point, surface-surface and surface-void  correlation functions. Periodic boundary conditions are used when periodic is true, otherwise CW boundary conditions are used.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#Directions","page":"Directional Functions","title":"Directions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Version 0.9 and newer: Now there are special types serving as direction designators in the module Utilities: Available directions.","category":"page"},{"location":"directional.html#Indicator-Functions","page":"Directional Functions","title":"Indicator Functions","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Internally, the functions c2, surf2 and surfvoid (see Correlation Functions) are reduced to s2 passing more generic indicator functions rather than simply a phase. This feature is also exposed to users. If you want to use a custom indicator function, you need to wrap it to either SeparableIndicator or InseparableIndicator structure, calling the corresponding constructor. Note that s2 performs much better on big arrays when using SeparableIndicator.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Directional.AbstractIndicator\nDirectional.SeparableIndicator\nDirectional.InseparableIndicator","category":"page"},{"location":"directional.html#CorrelationFunctions.Directional.AbstractIndicator","page":"Directional Functions","title":"CorrelationFunctions.Directional.AbstractIndicator","text":"Abstract type for indicator functions mathbbR^2n rightarrow left0 1right where n = 1 2 text or  3.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Directional.SeparableIndicator","page":"Directional Functions","title":"CorrelationFunctions.Directional.SeparableIndicator","text":"SeparableIndicator(χ₁, χ₂)\n\nType for separable indicator function, that is for such an indicator function which can be written as chi(xy) = chi_1(x)chi_2(y).\n\nχ1 and χ2 must be functions of one argument which return a value of Bool type.\n\nNB: This indicator function is not symmetric (i.e. chi(xy) ne chi(yx)). This behaviour is intentional. For example you can write such an indicator, so the corresponding correlation function is sensitive to the spatial orientation of a system.\n\n\"That one, too fat! This one, too tall! This one… too symmetrical!\"\n\n\n\n\n\n","category":"type"},{"location":"directional.html#CorrelationFunctions.Directional.InseparableIndicator","page":"Directional Functions","title":"CorrelationFunctions.Directional.InseparableIndicator","text":"InseparableIndicator(χ)\n\nType for inseparable indicator function, that is for such an indicator function which cannot be written as chi(xy) = max(Chi(x y) Chi(y x)), where Chi(x y) = chi_1(x)chi_2(y).\n\nχ must be a function of two arguments which returns a value of Bool type.\n\n\n\n\n\n","category":"type"},{"location":"directional.html#Results","page":"Directional Functions","title":"Results","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"CorrelationFunctions.jl is tested on overlapping disks and balls of constant radius R with centers generated by Poisson process with parameter lambda (see section 5.1 of Random Heterogeneous Materials). An example of a two-dimensional two-phase system generated in this way is on the picture (R = 25 and lambda = 5 cdot 10^-4):","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"(Image: disks)","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Plots of all correlation functions calculated by CorrelationFunctions.jl for overlapping disks along with their theoretical values are given below. There are also plots of relative errors calculated as","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"texterr(x) = mid fractextcalculation(x) -\ntexttheory(x)texttheory(x) mid","category":"page"},{"location":"directional.html#Two-dimensional-systems","page":"Directional Functions","title":"Two-dimensional systems","text":"","category":"section"},{"location":"directional.html#Methodology","page":"Directional Functions","title":"Methodology","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"All functions in this section with exception of pore size and chord length functions are calculated on 15 random datasets generated with parameters R = 25 and lambda = 5 cdot 10^-4. Each dataset is an image with dimensions 4000x4000 pixels. The final result is an average of results on those 15 datasets. When function fastly decreases to zero a plot of a natural logarithm of that function is provided.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size and chord length functions are calculated on one 4000x4000 dataset with the same parameters as above. A theoretical value is computed by averaging a theoretical function across each bin of a histogram returned by pore_size or chord_length function. Because both pore size and cord length functions decrease to zero with increase of their arguments, the relative errors are calculated for the corresponding cummulative distribution functions.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"All functions are called with default optional arguments unless explicitly stated otherwise.","category":"page"},{"location":"directional.html#Two-point-S_2(x)-function","page":"Directional Functions","title":"Two point S_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"S2 Error\n(Image: s2) (Image: s2 error)","category":"page"},{"location":"directional.html#Lineal-path-L_2(x)-function","page":"Directional Functions","title":"Lineal path L_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"L2 Error\n(Image: l2) (Image: l2 error)","category":"page"},{"location":"directional.html#Surface-surface-F_{ss}(x)-function","page":"Directional Functions","title":"Surface-surface F_ss(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-surface Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Surface-void-F_{sv}(x)-function","page":"Directional Functions","title":"Surface-void F_sv(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-void Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Pore-size-P(x)-function","page":"Directional Functions","title":"Pore size P(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Chord-length-p(x)-function","page":"Directional Functions","title":"Chord length p(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length function chord_length was called with parameter nbins = 30.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Three-dimensional-systems","page":"Directional Functions","title":"Three-dimensional systems","text":"","category":"section"},{"location":"directional.html#Methodology-2","page":"Directional Functions","title":"Methodology","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"The idea is the same as in two-dimensional case, but chosen parameters are slightly different. The functions are averaged over 5 500x500x500 datasets with ball radius R = 20 and Poisson process parameter lambda = 3 cdot 10^-5.","category":"page"},{"location":"directional.html#Two-point-S_2(x)-function-2","page":"Directional Functions","title":"Two point S_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"S2 Error\n(Image: s2) (Image: s2 error)","category":"page"},{"location":"directional.html#Lineal-path-L_2(x)-function-2","page":"Directional Functions","title":"Lineal path L_2(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"L2 Error\n(Image: l2) (Image: l2 error)","category":"page"},{"location":"directional.html#Surface-surface-F_{ss}(x)-function-2","page":"Directional Functions","title":"Surface-surface F_ss(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-surface Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Surface-void-F_{sv}(x)-function-2","page":"Directional Functions","title":"Surface-void F_sv(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Surface-void Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Pore-size-P(x)-function-2","page":"Directional Functions","title":"Pore size P(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Pore size Error\n(Image: ss) (Image: ss error)","category":"page"},{"location":"directional.html#Chord-length-p(x)-function-2","page":"Directional Functions","title":"Chord length p(x) function","text":"","category":"section"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length function chord_length was called with parameter nbins = 30.","category":"page"},{"location":"directional.html","page":"Directional Functions","title":"Directional Functions","text":"Chord length Error\n(Image: ss) (Image: ss error)","category":"page"}]
}
